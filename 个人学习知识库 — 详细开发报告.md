下面是一份面向工程实现、可直接交给 AI IDE / 开发团队参考的**可执行性开发报告**。它包含：总体架构、技术栈、模块拆分、数据模型、IPC/后端接口定义、LLM & 向量检索集成方案、艾宾浩斯复习调度策略、插件/扩展设计、安全与部署建议、开发里程碑与测试要点等细节。按你要求：**完全本地优先**（默认在本地做 NLP/LLM 处理；用户勾选“共享数据”后可切换到服务端），且 **可通过后端接口获取可调用模型列表**（模型名称/URL 不在 electron 中写死）。

---

# 1 高层架构概览

简要说明：桌面端采用 **Electron**（桌面优先，后续可适配 Web），前端用 **Vue 3 + Vite + Pinia**，后端/服务分两类：

- **本地处理层（Local Worker）**：可选的本地 Python/Node 进程或 WASM/Native 模型运行时，负责 embeddings、语义检索、（可选）本地 LLM 推理。
    
- **远程服务层（Server API）**：当用户勾选共享/云处理或本地能力不足时，Electron 调用远端 API（获取模型列表、提交任务、接收结果）。
    
- **本地数据库 & 向量存储**：关系型元数据（SQLite）+ 向量检索（本地向量 DB 或 SQLite+Faiss/Annoy/Weaviate-lite 等，可通过本地 Worker 管理）。
    

架构图（文字版）：

`[Electron UI (Vue 3 + Pinia)]       │ IPC / preload (contextIsolation)       ▼ [Main process (Electron)]  ←→  File system (notes .md/.docx)       │       ├─ Local Worker (Python/Node/WASM)  ← embeddings / semantic index / local LLM       │      └─ Vector DB (faiss/annoy/sqlite+rtree)       │       └─ Remote API (optional)  ←— GET /models, POST /query, POST /embed`

---

# 2 推荐技术栈（具体包/工具）

## 桌面 & 前端

- **Electron**：`electron-forge`（或 `electron-builder` 用于最终打包）。
    
    - 推荐使用 `electron-forge` 做开发模板、热重载；打包时用 `electron-builder` 生成安装包。
        
- **前端**：`Vue 3` + `Vite`（快速开发与热重载）。
    
- **状态管理**：`Pinia`（轻量且与 Vue 3 深度集成）。
    
- **UI**：Tailwind CSS
    
- **富文本/笔记编辑**：
    
    - Markdown 渲染：`markdown-it` + 插件（代码高亮 `highlight.js` / `prismjs`，表格、任务列表、数学公式 KaTeX）。
        
    - Markdown 编辑器：`@toast-ui/editor` / `monaco-editor`（如果需要 IDE 风格）。
        
- **Word (docx) 读取**：`mammoth`（Node）或调用本地转换器（LibreOffice CLI）做 docx → markdown 转换。
    
- **打包/构建脚本**：npm scripts + CI（GitHub Actions / GitLab CI）。
    

## 数据存储 & 本地服务

- **元数据存储（笔记、用户设置、复习记录）**：`SQLite`（本地单文件数据库）
    
    - Node 推荐驱动：`better-sqlite3`（同步、性能好，适合 Electron）。
        
- **向量检索（semantic search）**（本地实现可选方案）：
    
    - 方案A（轻量）：`sqlite` + `persistence` 存 embedding（float blob），用 `annoy` / `hnswlib`（Python）做 nearest neighbor，Local Worker 提供查询接口。
        
    - 方案B（纯 JS）：`faiss` 无原生 JS，推荐在 local worker 用 Python + faiss 或 `hnswlib`。也可使用 `weaviate`/`milvus` (重) 或 `qdrant` （本地部署ed）。
        
- **本地 Worker**（运行 embeddings/LLM）：
    
    - Python 服务（推荐）：`FastAPI` 做本地 HTTP 服务，使用 `sentence-transformers` 或支持的推理框架。
        
    - 如果想把一切 JS 化：可用 `onnxruntime` 或 `llama.cpp` 的 Node 绑定（更复杂）。
        
- **向量/嵌入存储位置**：与 SQLite 同目录或专门的 `./data` 文件夹（userData 下）。
    

## LLM / Embedding Provider 抽象
调用后端接口获取可用模型列表，根据用户选择实现不同的模型调用

---

# 3 模块拆分（详细）

## A. Electron 主流程（main）

- 启动、窗口管理、菜单、系统通知。
    
- 负责启动/管理 Local Worker（子进程），管理本地服务生命周期。
    
- 提供安全的 IPC：**使用 preload 脚本，contextIsolation=true，暴露受控 API 给渲染进程**。
    
- 管理数据库连接（主进程与 local worker 直接通信或通过主进程代理）。
    

## B. Preload 脚本（安全边界）

- 暴露受限 API：`window.api.getNotes()`, `window.api.readFile()`, `window.api.invokeSearch(query)`, `window.api.openSettings()` 等。
    
- 仅暴露白名单函数，所有外部请求走主进程验证与审计。
    

## C. 渲染进程（Vue）

- 页面：Dashboard、笔记列表、笔记编辑器、复习日程、智能问答、设置、插件市场。
    
- 状态（Pinia）：用户信息、当前笔记、搜索结果、模型列表、插件信息、复习队列。
    
- UI 组件：侧边栏、标签/笔记树、笔记卡片、编辑器、复习提醒卡片、对话窗口（智能问答）。
    

## D. 本地 Worker（可选）

- 运行 embeddings、索引更新、语义搜索、（可选）本地 LLM 推理。
    
- 提供 HTTP/Unix Socket 接口，主进程或渲染进程（通过 IPC）调用。
    
- 可配置为自动随 Electron 启动，或用户手动启停。
    

## E. 后端 / 云（可选）

- 提供模型目录（`GET /api/models`），模型元信息（name、capabilities、URL/endpoint、latency、cost指标）。
    
- 提供托管推理（当用户勾选共享数据/云处理），并记录审计/隐私策略。
    
- 强烈建议对用户数据进行分级与脱敏（可选）。
    

## F. 插件系统

- 插件运行环境：**前端插件（JS）** 
    
- 每个插件有 manifest.json（id、name、permissions、entry point、version）。
    
- 插件沙箱：渲染进程中只允许插件调用白名单 API（通过主进程中间层），并限制文件/网络访问权限（用户授权）。
    
- 插件市场（本地化）：可在本地加载 `.zip` 插件或从远端仓库安装（用户许可）。
    

---

# 4 数据模型

自己看着处理
---

# 5 语义检索与 LLM 问答流程

## 5.1 索引流程（新增/更新笔记）

1. 监听笔记新增/更新事件（文件系统或编辑器保存）。
    
2. 清洗文本（去除非文本二进制、拆分长文本成 chunks，chunk size 推荐 200–500 tokens，overlap 50–100 tokens）。
    
3. 对每个 chunk 调用 Embedding Provider（本地 worker 或远端），得到向量。
    
4. 将向量存入向量索引（faiss/hnswlib/annoy）并在 `embeddings` 表写入映射。
    
5. 保持索引可持久化（保存索引文件到 data 目录）。
    

## 5.2 查询流程（语义搜索 + 回答）

1. 用户在 UI 输入 query。
    
2. App 将 query 发给 Embedding Provider 得到 query vector。
    
3. 在向量索引里做近邻检索（top-k，k=5–10），取出相关 chunks（带得分）。
    
4. 做【检索增强（RAG）】：将 top chunks 拼接成上下文（加上元信息如来源、时间），发给 LLM 做回答/摘要/纠错。
    
    - **本地优先**：如果本地 LLM 可用，先在本地生成答案（安全、低延迟）。
        
    - **云备选**：如果本地能力不足或用户选择“云处理”，将上下文与 query 发给远端 LLM。
        
5. 结合检索得分，给出答案并标注来源（引用原笔记段落 & 跳转链接），并在 UI 提供“标记为错误 / 补充 / 接受建议”的交互，以便后续修订。
    


---

# 6 后端 API 设计（示例）

**GET /api/models**

- 返回：`[{ id, name, provider, endpoint, capabilities, cost, supports_embedding }]`
    

**POST /api/embed**

- body: `{ model_id, texts: [ ... ] }`
    
- 返回：`{ embeddings: [[...], ...] }`
    

**POST /api/generate**

- body: `{ model_id, prompt, max_tokens, temperature, context_chunks?: [...]}`
    
- 返回：`{ text, tokens_used }`
    

**POST /api/feedback**

- body: `{ query_id, user_feedback }` — 用以改进检索/模型选择（若用户同意上报）。
    

> 注意：Electron 端只保存 model_id / endpoint 地址，实际调用时通过用户设置决定使用本地还是远端 provider。

---

# 7 艾宾浩斯遗忘曲线 & 复习调度实现建议

## 基本概念（结合 SM-2 算法）

建议采用 SM-2（Anki 使用的间隔重复算法，可以很好替代简单日期列表）：

- 每次复习后，记录 `quality`（0–5）由用户反馈（或自动判断答对/答错）。
    
- 根据 `quality` 更新 `ease_factor`、`interval_days`、`repetition_count`，计算 `next_review_at`：
    
    - 若 `quality < 3`： repetition_count = 0; interval = 1
        
    - 否则：
        
        - if repetition_count == 1 → interval = 1
            
        - if repetition_count == 2 → interval = 6
            
        - else → interval = previous_interval * ease_factor
            
    - ease_factor = max(1.3, ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)))
        

## 实现细节

- 在 `review_schedule` 表存储 `ease_factor`, `interval_days`, `repetition_count`, `next_review_at`。
    
- 后台服务（轮询或启动时）计算“今日复习列表”，并触发系统通知（Electron Notification API）或应用内提醒。
    
- 支持“打卡复习”与“批量复习”视图，并在复习结束后把用户反馈写回数据库并更新索引（如修正文档片段）。
    

---

# 8 插件系统设计（详细）

## 插件类型

- **UI 插件（前端）**：用 JS/TS 写，运行在渲染进程的沙箱里（受限 API）。用于自定义面板、导出器、快捷操作等。

## 插件 Manifest（示例）

`{   "id": "note-exporter",   "name": "Note Exporter",   "version": "0.1.0",   "entry": "main.js",   "permissions": ["read_notes", "write_files", "open_window"],   "ui": {     "menu": ["Tools > Export"],     "panel": "export-panel"   } }`

## 安全与权限

- 插件运行前提示权限弹窗（类似移动端授权）。
    
- 所有插件只能通过主进程受控 API 访问文件系统、网络（并可被用户逐项禁用）。
    
- 插件签名机制（可选）：离线插件可以由用户加载，但来自官方市场的插件建议带数字签名校验。
软件布局：
1. 软件左上角为软件图标（请你先随便找个图标代替）  
2. 去掉软件的菜单栏，并且在软件的顶部栏（即你理解的标题栏）添加个文件列表的收起和展开的按钮来控制是否展示文件列表（文件列表中放置一个展示当前文档大纲功能）以及搜索按钮，点击搜索按钮之后将搜索的页面挂载到文件列表的区域  
3. 软件左下角展示设置按钮  
4. 底部展示一个状态栏（右下角展示文档信息（字数，行列等信息））  
5. 在软件右上角的最小化左边展示一个圆形用户头像，当鼠标悬浮上之后展示个人信息卡片以及个人空间和学习提醒的按钮  
6. 左侧导航栏中的按钮有文档，订阅，复习计划，日记等功能。  
7. 在设置中能够更改配色
8. 在设置中能切换语言，支持中文和英文
9. 实现多标签页